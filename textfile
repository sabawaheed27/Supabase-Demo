 On the server (SSR)

The server is like a library where many people (users) come.
If everyone used the same notebook, people could accidentally see each other’s notes.
So → every time a new person (user request) comes, the server gives them a fresh notebook (a new QueryClient).
This keeps each user’s data separate and private.

In the browser (client)
On your personal computer, you are the only one using it.
If your app created a new notebook every time you clicked a button or changed a page, you’d lose your notes (the cache).
So → the browser uses one notebook (a single QueryClient) and reuses it, so your data stays around while you browse.
 This makes your app faster and smoother, because it remembers what it already fetched.
Server: New notebook for every visitor → no data leaks.
Browser: One notebook reused → cache stays, no need to re-fetch everything.



Pages: These are what users navigate to in the browser (/auth/signup, /auth/login).
Forms: These are reusable React components (SignUpForm, LogInForm) that sit inside the pages and handle collecting user input.
Layout: AuthLayout is a wrapper that gives both signup/login pages a consistent structure (e.g. a logo at the top).
Actions: (like SignUp in @/action/sign-up) handle what happens when the form is submitted (saving data, making API calls, etc.).
/app
 └── /auth
      ├── signup/page.tsx    ← signup page (uses SignUpForm)
      ├── login/page.tsx     ← login page (uses LogInForm)
      └── layout.tsx         ← optional AuthLayout wrapper
/components
 ├── SignUpForm.tsx          ← signup form
 ├── LogInForm.tsx           ← login form
 └── Logo.tsx
/actions
 └── sign-up.ts              ← server action for signup

How Signup Works
User goes to /auth/signup → Next.js loads SignUpPage.
Inside SignUpPage, you render <SignUpForm />.
SignUpForm has a <form  action={SignUp}>…</form>.
This means when the user submits the form, the server action SignUp is called.
SignUp (in /actions/sign-up.ts) will actually create the user account.

How Login Works
User goes to /auth/login → Next.js loads LogInPage.
Inside LogInPage, you render <LogInForm />
LogInForm has a <form> (you’ll probably want to add an action={LogIn} similar to signup).
LogIn (a server action you create, e.g. /actions/log-in.ts) will check credentials and log the user in.

How Signup & Login Connect
Navigation: Each page gives a link to the other:
On signup → “Already have an account? Log in here!”
On login → “Don’t have an account? Sign up here!”
Backend logic:
Signup creates a user (via SignUp action).
Login authenticates an existing user (you’ll need a LogIn action).

auth/signup/page.tsx → shows the signup form.
auth/login/page.tsx → shows the login form.



npm i react-hook-form  @hookform/resolvers 

SUPABASE:

Supabase is the backend.
Think of it like your project’s database + authentication + API layer all in one.
Supabase uses PostgreSQL under the hood.
In your getHomePosts function, you’re querying Supabase to get a list of posts and their associated user data.


npm install supabase --save-dev
npx supabase login
npx supab
ase gen types typescript --project-id  > utils/supabase/database.types.ts
Debugger attached.
